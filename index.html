<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>TBC Networks Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />
  <style>
    html, body { height: 100%; margin: 0; }
    #map { height: 100%; }

    /* Title (fixed 40px) */
    .map-title {
      position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
      z-index: 1000;
      font: 40px/1.2 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      font-weight: 800; color: #111; text-align: center;
      background: rgba(255,255,255,0.9);
      padding: 14px 25px; border-radius: 20px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      pointer-events: none;
    }

    /* Left legend panel */
    .legend-panel {
      position: absolute;
      top: 70px; left: 10px;
      width: 260px; max-height: calc(100% - 90px);
      overflow: auto;
      z-index: 1000;
      background: rgba(255,255,255,0.95);
      border: 1px solid #e5e7eb;
      border-radius: 12px;
      box-shadow: 0 4px 16px rgba(0,0,0,.12);
      padding: 10px;
      font: 13px/1.35 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }
    .legend-title {
      font-weight: 700; font-size: 14px; margin: 4px 0 8px; color: #111;
    }
    .legend-list { list-style: none; padding: 0; margin: 0; position: relative; }
    .legend-item {
      display: flex; align-items: center; gap: 10px;
      padding: 6px 6px; border-radius: 8px;
      cursor: pointer;
    }
    .legend-item:hover { background: #f3f4f6; }
    .swatch {
      width: 16px; height: 16px; border-radius: 4px;
      border: 1px solid rgba(0,0,0,.15); flex: 0 0 16px;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.25);
    }
    .legend-name { color: #111; }

    /* Legend popup (same visual language as map popups/tooltips) */
    .legend-popup {
      position: absolute;
      left: 8px;
      right: 8px;
      z-index: 5;
      background: #fff;
      color: #111;
      border: 1px solid #e5e7eb;
      border-radius: 10px;
      box-shadow: 0 4px 14px rgba(0,0,0,.12);
      padding: 10px 12px 12px;
    }
    .legend-popup .close {
      position: absolute; top: 6px; right: 8px;
      border: none; background: transparent; font-size: 16px;
      line-height: 1; cursor: pointer; color: #6b7280;
    }
    .legend-popup .close:hover { color: #111; }

    .leaflet-interactive { cursor: pointer; }

    /* Tooltip / popup content */
    .tip { font: 13px/1.35 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    .tip .label { color:#666; }
    .tip-name { font-size: 15px; font-weight: 600; margin-bottom: 2px; color: #111; }

    /* Permanent polygon labels on map */
    .poly-label {
      background: transparent; border: 0; box-shadow: none;
      color: #1f2937;
      font: 13px/1.2 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      text-align: center; white-space: nowrap; line-height: 1.15;
      text-shadow: 0 1px 2px rgba(255,255,255,.85), 0 0 2px rgba(255,255,255,.9);
      pointer-events: none;
    }

    /* Hover tooltip styled like a mini popup */
    .leaflet-tooltip.hover-tip {
      background: #fff; color: #111;
      border: 1px solid #e5e7eb; border-radius: 10px;
      box-shadow: 0 4px 14px rgba(0,0,0,.12);
      padding: 8px 10px;
    }
    .leaflet-tooltip.hover-tip:before { display: none; }

    /* Photo grid */
    .gallery {
      display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
      gap: 8px; margin-top: 8px;
    }
    .gallery a { display:block; border-radius:8px; overflow:hidden; box-shadow: 0 1px 4px rgba(0,0,0,.12); }
    .gallery img { display:block; width:100%; height:100%; object-fit: cover; aspect-ratio: 4 / 3; }
    hr { border:0; border-top:1px solid #e9ecef; margin:8px 0; }

    /* Headings in layer control */
    .leaflet-control-layers .basemap-heading,
    .leaflet-control-layers .overlays-heading {
      font-weight: 600; margin-bottom: 4px; display: block;
    }
  </style>
</head>
<body>
  <div id="map">
    <div class="map-title">TBC Networks</div>

    <!-- Legend panel -->
    <aside class="legend-panel">
      <div class="legend-title">Networks</div>
      <ul id="legendList" class="legend-list"></ul>
    </aside>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
  <script>
    // --- Map ---
    const map = L.map('map', { center: [37.8, -122.3], zoom: 9, preferCanvas: true });

    // --- Basemaps (your four, relabeled) ---
    const esriGray = L.tileLayer(
      'https://server.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Light_Gray_Base/MapServer/tile/{z}/{y}/{x}',
      { maxZoom: 20, attribution: 'Tiles &copy; Esri' }
    ).addTo(map); // default
    const cartoPositron = L.tileLayer(
      'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png',
      { maxZoom: 20, subdomains: 'abcd', attribution: '&copy; OpenStreetMap contributors &copy; CARTO' }
    );
    const esriWorldStreet = L.tileLayer(
      'https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}',
      { maxZoom: 20, attribution: 'Tiles &copy; Esri' }
    );
    const esriTopo = L.tileLayer(
      'https://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}',
      { maxZoom: 20, attribution: 'Tiles &copy; Esri' }
    );
    const baseMaps = { 'Light': esriGray, 'Medium': cartoPositron, 'Street': esriWorldStreet, 'Topo': esriTopo };

    // --- Overlays ---
    const networksGroup = L.layerGroup().addTo(map);
    const countiesGroup = L.layerGroup().addTo(map);

    const layerControl = L.control.layers(baseMaps, { 'Networks': networksGroup, 'Counties': countiesGroup }, { position: 'topright', collapsed: false }).addTo(map);
    const controlEl = layerControl.getContainer();
    const baseList = controlEl.querySelector('.leaflet-control-layers-base');
    if (baseList) { const h = document.createElement('div'); h.className = 'basemap-heading'; h.textContent = 'Basemap'; baseList.prepend(h); }
    const overlayList = controlEl.querySelector('.leaflet-control-layers-overlays');
    if (overlayList) { const h = document.createElement('div'); h.className = 'overlays-heading'; h.textContent = 'Layers'; overlayList.prepend(h); }

    // --- Networks helpers ---
    const palette30 = [
      '#1f77b4','#ff7f0e','#2ca02c','#d62728','#9467bd',
      '#8c564b','#e377c2','#7f7f7f','#bcbd22','#17becf',
      '#393b79','#637939','#8c6d31','#843c39','#7b4173',
      '#3182bd','#31a354','#756bb1','#636363','#e6550d',
      '#9edae5','#c7c7c7','#bc80bd','#ffed6f','#a6cee3',
      '#b2df8a','#fb9a99','#fdbf6f','#cab2d6','#6a3d9a'
    ];
    function hashIndex(str, m) { let h = 0; for (let i=0;i<str.length;i++) h = (h*31 + str.charCodeAt(i))|0; return Math.abs(h)%m; }
    function colorForFeature(ft) {
      const p = ft.properties || {};
      const key = String(p.id || p.name || JSON.stringify(ft.geometry) || Math.random());
      return palette30[hashIndex(key, palette30.length)];
    }
    function styleNetworks(ft) { return { color: '#333', weight: 1.5, fillColor: colorForFeature(ft), fillOpacity: 0.5 }; }
    function highlight(e){ e.target.setStyle({ weight: 3, color:'#000', fillOpacity: 0.7 }); }
    function resetHighlight(e){ networksGeoJson && networksGeoJson.resetStyle(e.target); }
    function cleanedName(name){ if (!name || typeof name !== 'string') return 'Unnamed'; return name.replace(/\bnetworks?\b/gi,'').replace(/\s+/g,' ').trim() || 'Unnamed'; }
    function multilineName(name){ return cleanedName(name).split(/\s+/).filter(Boolean).join('<br>'); }
    function allPhotos(props = []){ return [props.photo1,props.photo2,props.photo3,props.photo4,props.photo5,props.photo6].filter(u => typeof u === 'string' && u.trim()); }
    function renderGallery(photos){
      if (!photos.length) return '';
      const items = photos.map((p, i) =>
        '<a href="' + p + '" target="_blank" rel="noopener">' +
          '<img src="' + p + '" alt="Photo ' + (i+1) + '" loading="lazy" />' +
        '</a>'
      ).join('');
      return '<hr/><div class="gallery">' + items + '</div>';
    }
    function infoCardHtml(props = {}){
      const name = cleanedName(props.name);
      const email = props.contact_email
        ? '<div><span class="label">Email:</span> <a href="mailto:' + props.contact_email + '">' + props.contact_email + '</a></div>'
        : '';
      const photos = allPhotos(props);
      return (
        '<div class="tip">' +
          '<div class="tip-name">' + name + '</div>' +
          '<div><span class="label">Leaders:</span> ' + (props.leaders ?? 'â€”') + '</div>' +
          email +
          renderGallery(photos) +
        '</div>'
      );
    }

    // Legend storage
    const legendItems = [];
    const legendPanel = document.querySelector('.legend-panel');
    const legendList = document.getElementById('legendList');
    let legendPopupEl = null; // current popup element
    let legendPopupForIdx = null; // which item it's anchored to

    function showLegendPopup(idx, html) {
      // Remove any existing popup
      if (legendPopupEl) legendPopupEl.remove();

      // Build popup element
      const el = document.createElement('div');
      el.className = 'legend-popup';
      el.innerHTML = '<button class="close" aria-label="Close legend popup">&times;</button>' + html;

      // Insert into panel
      legendPanel.appendChild(el);

      // Position it just below the target list item
      const li = legendList.querySelector('li[data-idx="' + idx + '"]');
      const listRect = legendList.getBoundingClientRect();
      const liRect = li.getBoundingClientRect();

      const relativeTop = (liRect.top - listRect.top) + legendList.scrollTop + li.offsetHeight + 6;
      el.style.top = relativeTop + 'px';

      // Close behavior
      el.querySelector('.close').addEventListener('click', () => { el.remove(); legendPopupEl = null; legendPopupForIdx = null; });

      // Save refs
      legendPopupEl = el;
      legendPopupForIdx = idx;
    }

    // Reposition popup on legend scroll/resize
    function repositionLegendPopup() {
      if (!legendPopupEl || legendPopupForIdx == null) return;
      const li = legendList.querySelector('li[data-idx="' + legendPopupForIdx + '"]');
      if (!li) return;
      const listRect = legendList.getBoundingClientRect();
      const liRect = li.getBoundingClientRect();
      const relativeTop = (liRect.top - listRect.top) + legendList.scrollTop + li.offsetHeight + 6;
      legendPopupEl.style.top = relativeTop + 'px';
    }
    legendPanel.addEventListener('scroll', repositionLegendPopup);
    window.addEventListener('resize', repositionLegendPopup);

    // --- Load Networks ---
    let networksGeoJson;
    fetch('https://tbc-networks.onrender.com/networks.geojson', { cache: 'no-cache' })
      .then(res => res.json())
      .then(data => {
        networksGeoJson = L.geoJSON(data, {
          style: styleNetworks,
          onEachFeature: (feature, layer) => {
            // Permanent stacked label on map
            layer.bindTooltip(multilineName(feature.properties?.name), {
              permanent: true, direction: 'center', className: 'poly-label', opacity: 1
            });

            // Map hover card (unchanged)
            layer.on('mouseover', (e) => {
              highlight(e);
              const tip = L.tooltip({ className: 'hover-tip', direction: 'top', opacity: 0.95, offset: [0,-8] })
                .setContent(infoCardHtml(feature.properties))
                .setLatLng(e.latlng);
              layer._hoverTip = tip; tip.addTo(map);
            });
            layer.on('mousemove', (e) => { if (layer._hoverTip) layer._hoverTip.setLatLng(e.latlng); });
            layer.on('mouseout', (e) => {
              resetHighlight(e);
              if (layer._hoverTip) { map.removeLayer(layer._hoverTip); layer._hoverTip = null; }
            });

            // Map click popup (unchanged)
            layer.on('click', () => {
              layer.bindPopup(infoCardHtml(feature.properties), { maxWidth: 480 }).openPopup();
            });

            // Collect for legend
            const displayName = cleanedName(feature.properties?.name || 'Unnamed');
            legendItems.push({
              name: displayName,
              color: colorForFeature(feature),
              layer,
              props: feature.properties || {}
            });
          }
        }).addTo(networksGroup);

        // Fit to networks
        const b = networksGeoJson.getBounds();
        if (b.isValid()) map.fitBounds(b.pad(0.05));

        // Build the legend list
        buildLegend();
      });

    // --- Legend rendering & interactions ---
    function buildLegend() {
      // Sort by name (Aâ†’Z)
      legendItems.sort((a, b) => a.name.localeCompare(b.name, undefined, { sensitivity: 'base' }));
      legendList.innerHTML = '';

      legendItems.forEach((item, idx) => {
        const li = document.createElement('li');
        li.className = 'legend-item';
        li.setAttribute('data-idx', String(idx));

        const swatch = document.createElement('span');
        swatch.className = 'swatch';
        swatch.style.background = item.color;

        const label = document.createElement('span');
        label.className = 'legend-name';
        label.innerHTML = item.name;

        li.appendChild(swatch);
        li.appendChild(label);
        legendList.appendChild(li);

        // Click: show tooltip popup anchored to the legend item (no map zoom)
        li.addEventListener('click', () => {
          const html = infoCardHtml(item.props);
          showLegendPopup(idx, html);
        });
      });
    }

    // --- Counties ---
    function styleCounties(){ return { color:'#b59f3b', weight:1, fillColor:'#fff9c4', fillOpacity:0.5 }; }
    fetch('https://pastorplt.github.io/tbc_map/tbc_counties.geojson', { cache: 'no-cache' })
      .then(res => res.json())
      .then(data => {
        const counties = L.geoJSON(data, { style: styleCounties }).addTo(countiesGroup);
        const b = counties.getBounds();
        if (b.isValid()) {
          const current = map.getBounds();
          const union = current.isValid() ? current.extend(b) : b;
          map.fitBounds(union.pad(0.05));
        }
      });
  </script>
</body>
</html>
